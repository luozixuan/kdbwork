package Yan.processors.kdbversion;

/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.IOException;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.TimeZone;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.nifi.annotation.behavior.EventDriven;
import org.apache.nifi.annotation.behavior.InputRequirement;
import org.apache.nifi.annotation.behavior.InputRequirement.Requirement;
import org.apache.nifi.annotation.documentation.CapabilityDescription;
import org.apache.nifi.annotation.documentation.Tags;
import org.apache.nifi.annotation.lifecycle.OnScheduled;
import org.apache.nifi.annotation.lifecycle.OnShutdown;
import org.apache.nifi.annotation.lifecycle.OnUnscheduled;
import org.apache.nifi.components.PropertyDescriptor;
import org.apache.nifi.flowfile.FlowFile;
import org.apache.nifi.logging.ComponentLog;
import org.apache.nifi.processor.ProcessContext;
import org.apache.nifi.processor.ProcessSession;
import org.apache.nifi.processor.Relationship;
import org.apache.nifi.processor.exception.ProcessException;
import org.apache.nifi.processor.util.StandardValidators;

import com.exxeleron.qjava.QBasicConnection;
import com.exxeleron.qjava.QDateTime;
import com.exxeleron.qjava.QException;
import com.exxeleron.qjava.QKeyedTable;
import com.exxeleron.qjava.QTable;
import com.exxeleron.qjava.QTable.Row;
import com.exxeleron.qjava.QTimestamp;
import com.exxeleron.qjava.QType;

@EventDriven
@Tags({"kdb","insert"})
@InputRequirement(Requirement.INPUT_REQUIRED)
@CapabilityDescription("Writes the contents of a FlowFile to KDB")

public class  NewPutKDBIndicatorInfo extends AbstractKDBProcessor {

    public static final PropertyDescriptor TABLE_NAME = new PropertyDescriptor.Builder()
    .name("table name")
    .description("The table's name to input data")
    .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)
    .required(true)
    .build();

    static final Relationship REL_SUCCESS = new Relationship.Builder().name("success")
            .description("All FlowFiles that are written to KDB are routed to this relationship").build();
    static final Relationship REL_FAILURE = new Relationship.Builder().name("failure")
            .description("All FlowFiles that cannot be written to KDB are routed to this relationship").build();
    static final Relationship REL_RETRY = new Relationship.Builder().name("retry")
            .description("All FlowFiles that cannot be written to KDB due to IOException are routed to this relationship").build();
    /** insert function to ticker plant */
    private static final String Q_UPD = ".u.upd";
    private static final DateTimeFormatter DATETIME_FORMATTER_JSON = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm");
    private static final DateTimeFormatter DATETIME_FORMAT_KDB = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS");
    private static final DateTimeFormatter DATETIME_FORMAT_ALPACA = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
    private static final DateTimeFormatter TIMESTAMP_FORMAT_FROM = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSSSSS");
    private static final DateTimeFormatter TIMESTAMP_FORMAT_TO = DateTimeFormatter.ofPattern("yyyy.MM.dd'D'HH:mm:ss.SSSSSSSSS");
    private static final DateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd'D'HH:mm:ss.SSS");
    private static final NumberFormat nanosFormatter = new DecimalFormat("000000");
    private static final String LIST_DELIMITER = ",";
    private static final char[] EMPTY_CHAR_ARRAY = new char[0];
    private static final TimeZone TIME_ZONE = TimeZone.getDefault();
    private static final long DAY_MILLIS = 86400000L;
    private static final long QEPOCH_MILLIS = 10957 * DAY_MILLIS;
    
    private final static List<PropertyDescriptor> propertyDescriptors;
    private final static Set<Relationship> relationships;

    static {
        List<PropertyDescriptor> _propertyDescriptors = new ArrayList<>();
        _propertyDescriptors.addAll(descriptors);
        _propertyDescriptors.add(TABLE_NAME);
        propertyDescriptors = Collections.unmodifiableList(_propertyDescriptors);
        Set<Relationship> _relationships = new HashSet<>();
        _relationships.add(REL_SUCCESS);
        _relationships.add(REL_FAILURE);
        _relationships.add(REL_RETRY);
        relationships = Collections.unmodifiableSet(_relationships);
    }


    private final LinkedHashMap<String,String> metaMAP = new LinkedHashMap<>();
    
    @Override
    public Set<Relationship> getRelationships() {
        return relationships;
    }

    @Override
    public final List<PropertyDescriptor> getSupportedPropertyDescriptors() {
        return propertyDescriptors;
    }

    

    @OnScheduled
    public void onScheduled(final ProcessContext context) {
        getLogger().info("************DEBUG THE OnScheduledMethod");
        //openConnection(context);  
        //init(context);
    }
    
    
    
    
    @Override
    public void onTrigger(final ProcessContext context, final ProcessSession session) throws ProcessException {        
        
        FlowFile flowFile = session.get();
        if ( flowFile == null ) {
            return;
        } 
        final ComponentLog logger = getLogger();
        
        init(context);
        QBasicConnection qConnection = getConnection();       
        if(metaInfo == null){
            getLogger().info("try get the meta info");
            metaInfo = queryForMeta(context);
            QTable table = metaInfo.getKeys();            
            for (Row row : table) {
                String tar = (String)(row.toArray())[0];
                metaMAP.put(tar, (flowFile.getAttribute(tar+"_type")));              
            }
            //TODO this should be removed.
            metaMAP.remove("time");            
        }
        

        Object[] inputObject = new Object[metaMAP.size()]; 
        //HashMap<String,ArrayList<Double>> doubleMap = new HashMap<>();
        try {
/*            int index = 0;
            logger.info("Prepared to convert data to KDBTypes");
            for(Entry<String, String> entry : metaMAP.entrySet()){
                if(entry.getValue().equals("float_list")){
                    String firstName = entry.getKey().split("_")[0];
                    if(!doubleMap.keySet().contains(entry.getKey())){
                        doubleMap.put(firstName, new ArrayList<Double>());                        
                    }
                    Double e = (Double) convert(flowFile.getAttribute(entry.getKey()),"float");
                    doubleMap.get(firstName).add(e);
                }
                
            }*/
            
            int index = 0;
            for(Entry<String, String> entry : metaMAP.entrySet()){
/*                logger.info("Entry Key is : " + flowFile.getAttribute(entry.getKey()));
                logger.info("Entry Value is : " + entry.getValue());*/
/*                if(entry.getValue().equals("float_list")){
                    String firstName = entry.getKey().split("_")[0];
                    int cnt = doubleMap.get(firstName).size();
                    logger.info("Cnt list is : " + cnt);
                    Double[] tarDouList = new Double[cnt];
                    for(int i = 0;i < doubleMap.get(firstName).size();i ++){
                        logger.info("Put the double : " + doubleMap.get(firstName).get(i));
                        tarDouList[i] = doubleMap.get(firstName).get(i);
                     }
                    inputObject[index] = tarDouList;
                    index = index + cnt;
                }else{*/
                    inputObject[index] = convert(flowFile.getAttribute(entry.getKey()),entry.getValue());
                    index ++;
/*                }*/
                

             }
        } catch (QException e1) {
            e1.printStackTrace();
            logger.error("Could not convert the data to Qtypes");
            session.transfer(flowFile, REL_FAILURE);
            return;
        }catch (Exception e2) {
            e2.printStackTrace();
            logger.error("Could not convert the data due to the exception e" + e2);
            session.transfer(flowFile, REL_FAILURE);
            return;
        }

        try {
            String tabname = context.getProperty(TABLE_NAME).getValue();    
/*            logger.info("length of inpuObject is " + inputObject.length);
            for(int i=0;i<inputObject.length;i++){
                logger.info("The " + i + "'s object is"+ inputObject[i]);
            }*/

            qConnection.sync(Q_UPD, tabname,inputObject);      
            session.getProvenanceReporter().send(flowFile, context.getProperty(PORT).getValue());
            session.transfer(flowFile, REL_SUCCESS); 
        } catch (QException e) {
            logger.error("QException occured, need to check the transferred data " , e);
            session.transfer(flowFile, REL_FAILURE);
        }catch (IOException e) {
            logger.error("IOException, reset connection " , e);
            session.transfer(flowFile, REL_RETRY);
            try {
                qConnection.reset();
            } catch (IOException | QException e1) {
                logger.error("Error in checking the session or reset session " , e);
            }
        }
        try {
            connectionPool.put(qConnection);
        } catch (InterruptedException e) {
            logger.error("Error in putting back the connection to queue " , e);
            e.printStackTrace();
        }
        
    }
    
    @OnUnscheduled
    public void stop() {
        super.stop();
    }
    
    @OnShutdown
    public void shutdown() {
        super.stop();
    }

    public Object convert(String source, String targetType) throws QException, ParseException{        
        switch(targetType){
            case "symbol" : 
                return kdbValue(source);
            case "string":
                return kdbValueCharList(source);
            case "jsontime":
                return parseJSONDateTimeUTC(source,DATETIME_FORMATTER_JSON);
            case "kdbtime":
                return parseJSONDateTimeUTC(source,DATETIME_FORMAT_KDB);
            case "alpacatime":
                return parseJSONDateTimeUTC(source,DATETIME_FORMAT_ALPACA);
            case "timestamp":
                return kdbValueTimestamp(source,TIMESTAMP_FORMAT_FROM,TIMESTAMP_FORMAT_TO);
            case "float":
                return kdbFloatValue(Double.parseDouble(source));
            case "int":
                return kdbIntValue(Integer.parseInt(source));
            case "floatlist":
                return kdbFloatList(source);

        };
        return null;
       
        
    }
    
    protected QKeyedTable queryForMeta(ProcessContext context) {
        QBasicConnection connection = null;
        //QKeyedTable metaResponse;
        connection = openConnectionTemp(context);
        String tabName = context.getProperty(TABLE_NAME).getValue();       
        try {
            Object response = connection.sync("meta", tabName);
            return (QKeyedTable) response;
        } catch (QException | IOException e) {
            getLogger().error("Error in query meta table", e);
            return null;
        } finally {
            closeConnection(connection);
        }
    }
    
    public  Double[] kdbFloatList(String stringValue) throws QException {
        if (stringValue == null) {
                return  (Double[]) QType.getQNull(QType.DOUBLE_LIST);
        }else{
            String[] source = stringValue.split(LIST_DELIMITER);
            Double[] output = new Double[source.length];
            for(int i = 0; i < source.length; i++){
                output[i] = Double.parseDouble(source[i]);
            }
            return output;
        }

    }
    

    
    public static String kdbValue(String stringValue) throws QException {
        if (stringValue == null) {
                return (String) QType.getQNull(QType.SYMBOL);
        }
        return stringValue;
    }
    public static char[] kdbValueCharList(String stringValue) {
        if (stringValue == null) {
            return EMPTY_CHAR_ARRAY;
        }
        return stringValue.toCharArray();
    }
    
    
    
    /**
     * Convert from Java:LocalDateTime to kdb:timestamp.
     * @param dateTime
     * @return
     * @throws ParseException QException
     */
    public QTimestamp kdbValueTimestamp(String timestamp,DateTimeFormatter fommatterFrom,DateTimeFormatter fommaterTo) throws QException, ParseException{
        if (timestamp == null) {
                return (QTimestamp) QType.getQNull(QType.TIMESTAMP);
        }
        getLogger().info("Original timestamp is" + timestamp);
        LocalDateTime timeJ = LocalDateTime.parse(timestamp, fommatterFrom);
        getLogger().info("Timestamp before converted " + timeJ);
        String targetTime = timeJ.format(fommaterTo);
        getLogger().info("Timestamp is converted to" + timeJ.format(fommaterTo));
        return new QTimestamp(getNanos(getDateformat().parse(targetTime.substring(0, targetTime.lastIndexOf(".") + 4)))
                + getNanosformat().parse(targetTime.substring(targetTime.lastIndexOf(".") + 4)).longValue());
    }
    
    public static QDateTime parseJSONDateTimeUTC(String time,DateTimeFormatter fommatter) throws QException {
        LocalDateTime timeJ = LocalDateTime.parse(time, fommatter);
        
        if (timeJ == null) {
                return (QDateTime) QType.getQNull(QType.DATETIME);
        }
        return new QDateTime(toDate(timeJ));
        
    }
    public static Date toDate(LocalDateTime dateTime) {
        if (dateTime == null) {
            return null;
        }
        ZonedDateTime zonedDateTime = dateTime.atZone(TIME_ZONE.toZoneId());
        return Date.from(zonedDateTime.toInstant());
    }
    
    public static Double kdbFloatValue(Double floatValue) throws QException{
        if (floatValue == null) {
                return (Double) QType.getQNull(QType.DOUBLE);
        }
        return floatValue;
    }
    
    public static Integer kdbIntValue(Integer integerValue) throws QException {
        if (integerValue == null) {
                return (Integer) QType.getQNull(QType.INT);
        }
        return integerValue;
    }
    
    private static long getNanos( final Date datetime ) {
        return 1000000 * (tzOffsetFromQ(datetime.getTime()) - QEPOCH_MILLIS);
    }

    static long tzOffsetFromQ( final long dt ) {
        return dt + TIME_ZONE.getOffset(dt);
    }
    
    private static DateFormat getDateformat() {
        return (DateFormat) dateFormat.clone();
    }
    private static NumberFormat getNanosformat() {
        return (NumberFormat) nanosFormatter.clone();
    }
    
    
}

